---
layout: post
title: "C++笔记"
id: 150110
date: 2015-01-20 10:25:10
tags: 
- Blog
categories: 
- original
---

标准模板库（Standard Template Library，简称STL）是一个C++软件库，也是C++标准程序库的一部分。其中包含5个组件，分别为算法、容器、迭代器、函数、适配器。

###容器

STL中比较常用的容器是vector，set和map。vector封装数组，list封装了链表，map和set封装了二叉树等。

**vector**

vector可视为会自动扩展容量的数组，vector的特色有支持随机存取，在集合尾端增删元素很快，但是在集合中间增删元素比较费时。

vector 定义于 <vector> 头文件中。与其他STL组件一样，vector 属于std名称空间。
定义 vecrot<int> vec;


- 访问元素的方法

	-`vec[i]` - 访问索引值为 i 的元素引用。 (索引值从零起算，故第一个元素是vec[0]。)

	-`vec.at(i)` - 访问索引值为 i 的元素的引用，以 at() 访问会做数组边界检查，如果访问越界将会抛出一个例外，这是与operator[]的唯一差异。

	-`vec.front() `- 回传 vector 第一个元素的引用。

	-`vec.back()` - 回传 vector 最尾元素的引用。


- 新增或移除元素的方法

-`vec.push_back()` - 新增元素至 vector 的尾端，必要时会进行存储器配置。

-`vec.pop_back()` - 删除 vector 最尾端的元素。

-`vec.insert()` - 插入一个或多个元素至 vector 内的任意位置。

-`vec.erase()` - 删除 vector 中一个或多个元素。

-`vec.clear()` - 清空所有元素。


- 获取长度/容量

-`vec.size()` - 获取 vector 目前持有的元素个数。

-`vec.empty()` - 如果 vector 内部为空，则传回 true 值。

-`vec.capacity()` - 获取 vector 目前可容纳的最大元素个数。这个方法与存储器的配置有关，它通常只会增加，不会因为元素被删减而随之减少。


- 重新配置／重置长度

-`vec.reserve()` - 如有必要，可改变 vector 的容量大小（配置更多的存储器）。在众多的 STL 实做，容量只能增加，不可以减少。

-`vec.resize() `- 改变 vector 目前持有的元素个数。



- 迭代 (Iterator)

-`vec.begin()` - 回传一个Iterator，它指向 vector 第一个元素。

-`vec.end()` - 回传一个Iterator，它指向 vector 最尾端元素的下一个位置（请注意：它不是最末元素）。

-`vec.rbegin()` - 回传一个反向Iterator，它指向 vector 最尾端元素的。

-`vec.rend()` - 回传一个Iterator，它指向 vector 的第一个元素。

----------

**set**

set关联式容器。set作为一个容器也是用来存储同一数据类型的数据类型，并且能从一个数据集合中取出数据，在set中每个元素的值都*唯一，而且系统能根据元素的值自动进行排序*。set容器内所有元素都是以节点的方式来存储，其节点结构和链表差不多，指向父节点和子节点。
定义 set<int> a;

- 成员函数

-`a.insert()`- 插入元素

-`a.erase()`- 删除某元素（如果存在）

-`a.begin()`- 返回set容器的第一个元素

-`a.end()`- 返回set容器的最后一个元素

-`a.clear()`- 删除set容器中的所有的元素

-`a.empty()`- 判断set容器是否为空

-`a.max_size()`- 返回set容器可能包含的元素最大个数

-`a.size()`- 返回当前set容器中的元素个数

-`a.rbegin`- 返回的值和end()相同

-`a.rend()`- 返回的值和rbegin()相同

**map**

如果你需要一个键/值对（pair）来存储数据(map(key,value))，map是一个更好的选择。map内部自建一颗红黑树（一种非严格意义上的平衡二叉树），这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的。

定义 map<int,string> mapint;


- 成员函数

-`begin()`- 返回第一个元素的定位器(iterator)的地址

-`clear()`- 将一个 map 容器的全部元素删除

-`count()`- 返回对应某个关键字的元素的个数

-`empty()`- 测试一个 map 容器是否为空

-`end()`- 返回最后一个元素后面的定位器(iterator)的地址

-`equal_range()`- 返回一对定位器,它们分别指向第一个大于或等于给定的关键字的元素和第一个比给定的关键字大的元素

-`erase()`- 将一个或一定范围的元素删除

-`find()`- 求出与给定的关键字相等的元素的定位器

-`insert()`- 将一个元素或者一定数量的元素插入到 map 的特定位置中去

###容器迭代器iterator

**vector迭代器**

除了使用下标来访问vector对象的元素外，标准库还提供了另一种检测元素的方法：使用迭代器（iterator）。迭代器是一种允许程序员检查容器内元素，并实现元素遍历的数据类型。

标准库为每一种标准容器（包括vector）定义了一种迭代器类型。迭代器类型提供了比下标操作更一般化的方法：所有的标准库容器都定义了相应的迭代器类型，而只有少数的容器支持下标操作。因为迭代器对所有的容器都适用，现代C++程序更倾向于使用迭代器而不是下标操作访问容器元素，即使对支持下标操作的vector类型也这样。

**容器的iterator类型**

每种容器类型都定义了自己的迭代器类型，如vector：

vector<int>::iterator iter;

这条语句定义了一个名为iter的变量，它的数据类型是由vector<int>定义的iterator类型。每个标准库容器类型都定义了一个名为iterator的成员，这里的iterator与迭代器实际类型的含义相同。

不同的容器类定义了自己的iterator类型，用于访问容器内的元素。换句话说，每个容器定义了一种名为iterator的类型，而这种类型支持（概念上的）迭代器的各种行为。

**begin和end操作**

每种容器都定义了一对命名为begin和end的函数，用于返回迭代器。如果容器中有元素的话，由begin返回的迭代器指向第一个元素：

vector<int>::iterator iter = ivec.begin();

上述语句把iter初始化为由名为begin的vector操作返回的值。假设vector不空，初始化后，iter即指该元素为ivec[0]。

由end操作返回的迭代器指向vector的“末端元素的下一个”。通常称为超出末端迭代器(off-the-end iterator)，表明它指向了一个不存在的元素。如果vector为空，begin返回的迭代器与end返回的迭代器相同。

由end操作返回的迭代器并不指向vector中任何实际的元素，相反，它只是起一个哨兵（sentinel）的作用，表示我们已处理完vector中所有元素。

**vector迭代器的自增和解引用运算**

迭代器类型定义了一些操作来获取迭代器所指向的元素，并允许程序员将迭代器从一个元素移动到另一个元素。

迭代器类型可使用解引用操作符（*操作符）来访问迭代器所指向r 元素：

*iter = 0;

解引用操作符返回迭代器当前所指向的元素。假设iter指向vector对象ivec的第一个元素，那么*iter和ivec[0]就是指向同一个元素。上面这个语句的效果就是把这个元素的值赋为0。

迭代器使用自增操作符向前移动迭代器指向容器中下一个元素。从逻辑上说，迭代器的自增操作和int型对象的自增操作类似。对int对象来说，操作结果就是把int型值“加1”，而对迭代器对象则是把容器中的迭代器“向前移动一个位置”。因此，如果iter指向第一个元素，则++iter指向第二个元素。