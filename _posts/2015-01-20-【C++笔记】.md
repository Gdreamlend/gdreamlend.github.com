---
layout: post
title: "C++笔记"
id: 150110
date: 2015-01-20 10:25:10
tags: 
- Blog
categories: 
- original
---
###容器iterator
**vector迭代器**

除了使用下标来访问vector对象的元素外，标准库还提供了另一种检测元素的方法：使用迭代器（iterator）。迭代器是一种允许程序员检查容器内元素，并实现元素遍历的数据类型。

标准库为每一种标准容器（包括vector）定义了一种迭代器类型。迭代器类型提供了比下标操作更一般化的方法：所有的标准库容器都定义了相应的迭代器类型，而只有少数的容器支持下标操作。因为迭代器对所有的容器都适用，现代C++程序更倾向于使用迭代器而不是下标操作访问容器元素，即使对支持下标操作的vector类型也这样。

**容器的iterator类型**

每种容器类型都定义了自己的迭代器类型，如vector：

vector<int>::iterator iter;

这条语句定义了一个名为iter的变量，它的数据类型是由vector<int>定义的iterator类型。每个标准库容器类型都定义了一个名为iterator的成员，这里的iterator与迭代器实际类型的含义相同。

不同的容器类定义了自己的iterator类型，用于访问容器内的元素。换句话说，每个容器定义了一种名为iterator的类型，而这种类型支持（概念上的）迭代器的各种行为。

**begin和end操作**

每种容器都定义了一对命名为begin和end的函数，用于返回迭代器。如果容器中有元素的话，由begin返回的迭代器指向第一个元素：

vector<int>::iterator iter = ivec.begin();

上述语句把iter初始化为由名为begin的vector操作返回的值。假设vector不空，初始化后，iter即指该元素为ivec[0]。

由end操作返回的迭代器指向vector的“末端元素的下一个”。通常称为超出末端迭代器(off-the-end iterator)，表明它指向了一个不存在的元素。如果vector为空，begin返回的迭代器与end返回的迭代器相同。

由end操作返回的迭代器并不指向vector中任何实际的元素，相反，它只是起一个哨兵（sentinel）的作用，表示我们已处理完vector中所有元素。

**vector迭代器的自增和解引用运算**

迭代器类型定义了一些操作来获取迭代器所指向的元素，并允许程序员将迭代器从一个元素移动到另一个元素。

迭代器类型可使用解引用操作符（*操作符）来访问迭代器所指向r 元素：

*iter = 0;

解引用操作符返回迭代器当前所指向的元素。假设iter指向vector对象ivec的第一个元素，那么*iter和ivec[0]就是指向同一个元素。上面这个语句的效果就是把这个元素的值赋为0。

迭代器使用自增操作符向前移动迭代器指向容器中下一个元素。从逻辑上说，迭代器的自增操作和int型对象的自增操作类似。对int对象来说，操作结果就是把int型值“加1”，而对迭代器对象则是把容器中的迭代器“向前移动一个位置”。因此，如果iter指向第一个元素，则++iter指向第二个元素。