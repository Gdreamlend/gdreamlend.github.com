---
layout: post
title: "C++笔记"
id: 150110
date: 2015-01-20 10:25:10
tags: 
- Blog
categories: 
- original
---

标准模板库（Standard Template Library，简称STL）是一个C++软件库，也是C++标准程序库的一部分。其中包含5个组件，分别为算法、容器、迭代器、函数、适配器。

<!--more-->

###容器

STL中比较常用的容器是vector，set和map。vector封装数组，list封装了链表，map和set封装了二叉树等。

**vector**

vector可视为会自动扩展容量的数组，vector的特色有支持随机存取，在集合尾端增删元素很快，但是在集合中间增删元素比较费时。

vector 定义于 <vector> 头文件中。与其他STL组件一样，vector 属于std名称空间。
定义 vecrot<int> vec;


- 访问元素的方法

	-`vec[i]` - 访问索引值为 i 的元素引用。 (索引值从零起算，故第一个元素是vec[0]。)

	-`vec.at(i)` - 访问索引值为 i 的元素的引用，以 at() 访问会做数组边界检查，如果访问越界将会抛出一个例外，这是与operator[]的唯一差异。

	-`vec.front() `- 回传 vector 第一个元素的引用。

	-`vec.back()` - 回传 vector 最尾元素的引用。


- 新增或移除元素的方法

	-`vec.push_back()` - 新增元素至 vector 的尾端，必要时会进行存储器配置。
	
	-`vec.pop_back()` - 删除 vector 最尾端的元素。
	
	-`vec.insert()` - 插入一个或多个元素至 vector 内的任意位置。
	
	-`vec.erase()` - 删除 vector 中一个或多个元素。
	
	-`vec.clear()` - 清空所有元素。


- 获取长度/容量

	-`vec.size()` - 获取 vector 目前持有的元素个数。
	
	-`vec.empty()` - 如果 vector 内部为空，则传回 true 值。
	
	-`vec.capacity()` - 获取 vector 目前可容纳的最大元素个数。这个方法与存储器的配置有关，它通常只会增加，不会因为元素被删减而随之减少。


- 重新配置／重置长度

	-`vec.reserve()` - 如有必要，可改变 vector 的容量大小（配置更多的存储器）。在众多的 STL 实做，容量只能增加，不可以减少。
	
	-`vec.resize() `- 改变 vector 目前持有的元素个数。



- 迭代 (Iterator)

	-`vec.begin()` - 回传一个Iterator，它指向 vector 第一个元素。
	
	-`vec.end()` - 回传一个Iterator，它指向 vector 最尾端元素的下一个位置（请注意：它不是最末元素）。
	
	-`vec.rbegin()` - 回传一个反向Iterator，它指向 vector 最尾端元素的。
	
	-`vec.rend()` - 回传一个Iterator，它指向 vector 的第一个元素。

----------

**set**

set关联式容器。set作为一个容器也是用来存储同一数据类型的数据类型，并且能从一个数据集合中取出数据，在set中每个元素的值都*唯一，而且系统能根据元素的值自动进行排序*。set容器内所有元素都是以节点的方式来存储，其节点结构和链表差不多，指向父节点和子节点。
定义 set<int> a;

- 成员函数

	-`a.insert()`- 插入元素
	
	-`a.erase()`- 删除某元素（如果存在）
	
	-`a.begin()`- 返回set容器的第一个元素
	
	-`a.end()`- 返回set容器的最后一个元素
	
	-`a.clear()`- 删除set容器中的所有的元素
	
	-`a.empty()`- 判断set容器是否为空
	
	-`a.max_size()`- 返回set容器可能包含的元素最大个数
	
	-`a.size()`- 返回当前set容器中的元素个数
	
	-`a.rbegin`- 返回的值和end()相同
	
	-`a.rend()`- 返回的值和rbegin()相同

**map**

如果你需要一个键/值对（pair）来存储数据(map(key,value))，map是一个更好的选择。map内部自建一颗红黑树（一种非严格意义上的平衡二叉树），这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的。

定义 map<int,string> mapint;


- 成员函数

	-`begin()`- 返回第一个元素的定位器(iterator)的地址
	
	-`clear()`- 将一个 map 容器的全部元素删除
	
	-`count()`- 返回对应某个关键字的元素的个数
	
	-`empty()`- 测试一个 map 容器是否为空
	
	-`end()`- 返回最后一个元素后面的定位器(iterator)的地址
	
	-`equal_range()`- 返回一对定位器,它们分别指向第一个大于或等于给定的关键字的元素和第一个比给定的关键字大的元素
	
	-`erase()`- 将一个或一定范围的元素删除
	
	-`find()`- 求出与给定的关键字相等的元素的定位器
	
	-`insert()`- 将一个元素或者一定数量的元素插入到 map 的特定位置中去

###容器迭代器iterator

**vector迭代器**

除了使用下标来访问vector对象的元素外，标准库还提供了另一种检测元素的方法：使用迭代器（iterator）。迭代器是一种允许程序员检查容器内元素，并实现元素遍历的数据类型。

标准库为每一种标准容器（包括vector）定义了一种迭代器类型。迭代器类型提供了比下标操作更一般化的方法：所有的标准库容器都定义了相应的迭代器类型，而只有少数的容器支持下标操作。因为迭代器对所有的容器都适用，现代C++程序更倾向于使用迭代器而不是下标操作访问容器元素，即使对支持下标操作的vector类型也这样。

**容器的iterator类型**

每种容器类型都定义了自己的迭代器类型，如vector：

vector<int>::iterator iter;

这条语句定义了一个名为iter的变量，它的数据类型是由vector<int>定义的iterator类型。每个标准库容器类型都定义了一个名为iterator的成员，这里的iterator与迭代器实际类型的含义相同。

不同的容器类定义了自己的iterator类型，用于访问容器内的元素。换句话说，每个容器定义了一种名为iterator的类型，而这种类型支持（概念上的）迭代器的各种行为。

**begin和end操作**

每种容器都定义了一对命名为begin和end的函数，用于返回迭代器。如果容器中有元素的话，由begin返回的迭代器指向第一个元素：

vector<int>::iterator iter = ivec.begin();

上述语句把iter初始化为由名为begin的vector操作返回的值。假设vector不空，初始化后，iter即指该元素为ivec[0]。

由end操作返回的迭代器指向vector的“末端元素的下一个”。通常称为超出末端迭代器(off-the-end iterator)，表明它指向了一个不存在的元素。如果vector为空，begin返回的迭代器与end返回的迭代器相同。

由end操作返回的迭代器并不指向vector中任何实际的元素，相反，它只是起一个哨兵（sentinel）的作用，表示我们已处理完vector中所有元素。

**vector迭代器的自增和解引用运算**

迭代器类型定义了一些操作来获取迭代器所指向的元素，并允许程序员将迭代器从一个元素移动到另一个元素。

迭代器类型可使用解引用操作符（*操作符）来访问迭代器所指向r 元素：

*iter = 0;

解引用操作符返回迭代器当前所指向的元素。假设iter指向vector对象ivec的第一个元素，那么*iter和ivec[0]就是指向同一个元素。上面这个语句的效果就是把这个元素的值赋为0。

迭代器使用自增操作符向前移动迭代器指向容器中下一个元素。从逻辑上说，迭代器的自增操作和int型对象的自增操作类似。对int对象来说，操作结果就是把int型值“加1”，而对迭代器对象则是把容器中的迭代器“向前移动一个位置”。因此，如果iter指向第一个元素，则++iter指向第二个元素。

###hash表

 为提高hash表查找性能，除了考虑选择合适的hash表表长和完美的hash函数外，还必须考虑hash表处理冲突的能力。当hash函数对两个不同的数据项产生了相同的hash值时，冲突就产生了。对于冲突的处理，通常采用的方法可以分为三类：

1. 线性再散列法，简单的按顺序遍历hash表，寻找下一个可用的槽；
2. 非线性再散列法，计算一个新的hash值；
3. 外部拉链法，将hash表中的每个槽当作具有相同hash值的数据项所组成链表的头部，hash表将发生冲突的项添加到同一个链表中。

下面对这三种方法分别介绍。

**1.线性再散列法**

线性再散列法是形式最简单的处理冲突的方法。插入元素时，如果发生冲突，算法会简单的遍历hash表，直到找到表中的下一个空槽，并将该元素放入该槽中。查找元素时，首先散列值所指向的槽，如果没有找到匹配，则继续遍历hash表，直到：（1）找到相应的元素；（2）找到一个空槽（指示查找的元素不存在）；（3）整个hash表遍历完毕（指示该元素不存在并且hash表是满的）。下表显示了以线性再散列法将｛89，18，49，58，69｝5个元素插入hash表的过程。（hash函数为：hash(X)=X mod 10；hash表长一般用素数，这里为了说明方便取表长为10）

![](/images/c_table1.png)

第一次冲突发生在插入关键字49时，它被放在下一个空闲地址，即地址0。关键字58依次和18，89，49发生冲突，试选三次之后才找到一个空单元。对69的冲突用类似的方法处理。从以上过程可以看出，只要表中有空闲单元，总可以找到，但这里选择步长为1，将会在hash表中产生聚集，即：即使hash表相对较空，还是会在某些区域形成一些区块，这些区块中的任何活动都将设计更大的步长。但如果以5或更大的值作为步长，可以迅速地从拥挤区域移开，从而减少聚集现象的发生。事实上，只要hash表长和检查槽的步长是互质的，那么表中的每个槽都会被检查到。

线性再散列法有两个缺点：第一，不能从表中删除元素，因为相应的单元可能已经引起过冲突，元素绕过它存到了别处，例如，如果我们删除了18，那么其他的元素都会找不到。如果确实需要删除，可以采用懒惰删除的方法。第二，当表被填满时性能下降明显。

**2.非线性再散列法**

线性再散列法是从冲突位置开始，采用一个步长以顺序方式遍历hash表，来查找一个可用的槽，从上面的讨论可以看出，它容易产生聚集现象。非线性再散列法可以避免遍历散列表，它会计算一个新的hash值，并通过它跳转到表中一个完全不同的部分。它的思想就是：通过跳转到表中不同的部分，从而避免相似值的聚集，如果再散列函数跳转到的槽已经被占用了，则继续执行新一轮的再散列和跳转。

例如，还是上面的例子，如果再散列函数是hash(X)=R-(X mod R)，其中R为小于hash表长的素数，如果我们选择R＝7，则下表显示了插入与前面相同的关键字的结果。

![](/images/c_table2.png)

 第一个冲突发生在49被插入的时候， hash(49)=7-0=7，故49被插入到位置6。Hash(58)=7-2=5，于是58被插入到位置3。最后69产生冲突，从而被插入到距离为hash(69)=7-6=1的地方。

非线性再散列法也有不能从表中删除元素的缺点。

无论是使用线性再散列法还是非线性再散列法，只有在散列表不会接近填满的情况下，才能使用再散列。当散列表的负载因子增大时，再散列所花费的时间也会显著增加。通过以上讨论可以看出，再散列方法适用于表负载较低并且不太可能执行删除操作的情况。

**3.外部拉链法**

外部拉链法是将hash表看作是一个链表数组，表中的每个槽要不为空，要不指向hash到该槽的表项的链表。可以通过把元素添加到链表中来解决冲突。同样，可以通过从链表中删除元素来执行删除操作。因此，解决冲突的代价不会超过向链表中添加一个节点，不需要执行再散列。在再散列中，表项的最大数量是由表中槽的原始数量确定的，与之不同的是，外部拉链法可以容纳的元素于将在内存中存放的元素一样多。

外部拉链法的原则是：hash表的大小一般与预料的元素个数差不多。

假设有一个表长为10的hash表，给出10个关键字为前10个自然数的平方，hash函数为hash(X)=X mod 10，下图就是对应的外部拉链法的hash表。

![](/images/c_table3.png)

外部拉链法的平均查找时间是对链表的查找时间加上1，这个1是最初的定位hash表槽。外部拉链法的缺点是：它需要稍微多一些的空间来实现，因为添加任何元素都需要添加指向节点的指针，并且每次探查也要花费稍微多一点的时间，因为它需要间接引用指针，而不是直接访问元素。由于今天的内存成本很低并且可以使用非常快的CPU，所以这些缺点都是微不足道的。因此，实际使用hash表时，一般都是使用拉链法来解决hash冲突。

[hash表部分 引用地址](http://blog.csdn.net/qll125596718/article/details/7028322)


###快速排序

1/28/2015 8:48:42 PM 

	QUICKSORT(A,p,r) //快排函数
	
		if p < r
		then q ← PARTITION(A, p, r)
			QUICKSORT(A, p, q - 1)//递归
			QUICKSORT(A, q + 1, r)//递归

	
	//一、key值为数组最后一个元素
	PARTITION(A,p,r)//数组划分函数（即一次排序）
	
		x ← A[r]
		i ← p - 1
		for j ← p to r - 1
			do if A[j] ≤ x
				then i ← i + 1
					exchange A[i] <-> A[j]
		exchange A[i + 1] <-> A[r]
		return i + 1

	//二、key值为数组首元素
	PARTITION(A,p,r)//数组划分函数
	
		x ← A[p]
	  	i ← p - 1
	  	j ← r + 1
	  	while TRUE
	    	do repeat j ← j - 1
	        	until A[j] ≤ x
	        repeat i ← i + 1
	           	until A[i] ≥ x
	        if i < j
	           	then exchange A[i] ↔ A[j]
	           	else return j
	
[原引用](http://blog.csdn.net/v_JULY_v/article/details/6116297)