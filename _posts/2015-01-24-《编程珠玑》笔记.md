---
layout: post
title: "编程珠玑笔记（二）"
id: 20150121
date: 2015-01-24 11:39:16
tags: 
- Programming Pearls
- Blog
categories: 
- original
---

###编程珠玑 第二章###

**A题**：给定一个最多包含40亿个随机排列的32位整数的顺序文件，找出一个不在文件中的32位整数。1、在文件中至少存在这样一个数？2、如果有足够内存，如何处理？ 3、如果内存不足，仅可以用文件来进行处理，如何处理？

<!--more-->

- 32位整数，包括-2146473648~~2146473647，约42亿个整数，而文件中只有40亿个，必然有整数少了。



- 如果采用位数思想来存放，则32位整数最多需要占用43亿个位。约512MB的内存空间  (2'32/8=512MB，这种情况是用一个位表示8bit)。

	可以采用前一章的位处理方法，然后判断每个int是否等于-1。因为-1的二进制表示是全1的。如果不等于-1。那么说明某一位没有置位。需要进行处理。

	如果是用个整数用一位表示出现与否，需要的内存大小：2'32/8/(1024*1024*1024)=0.5G.处理方法：我们遍历一遍文件，将出现的数对应的那一位置1，然后遍历这些位， 找到第一个有0的位即可，这一位对应的数没有出现。

- 按最高位分为两段，没有出现的那个数，肯定在比较小的段里面。

   	如果比较少的段最高位为1，那么缺少的那个数的最高位也为1。

	如果比较少的段最高位为0，那么少的那个数的最高位也是0。

	依次按以上方法去处理每个位。

	算法复杂度为O(n)。每次处理的部分都是上一次的一半。累加之后是O(n).思想与找第K小数的思想是一样的。只不过在这里是有一个自动分割的过程。而找第k小数的时候，是随机找一个数。

测试代码：

	#include <iostream>
	using namespace std;
	int split(int* a, int* b, int*c, int alen, int bit)
	{
	    int biter, citer, i;
	    int v=0, re = 0, *t;
	
	    while(bit--)//对数组按位进行0/1分割
		{
	        v = (1 << bit);
	        for(i=biter=citer=0; i < alen; i++) 
			{
	            if(a[i] & (1<<bit)) 
				{
	                b[biter++] = a[i];
	            } 
				else 
				{
	                c[citer++] = a[i];
	            }
	        }
			//当前bit位遍历一遍后，比较当前位置为0还是为1的数少，
			//如果为1则re+=v(即最后re是当前位为1的数)；
			//如果为0则re在当前位置为0（0*2的bit次方还是0所以re不用加）
	        if(biter <= citer) 
			{
	            re += v;
	            t = a;
	            a = b; //将位数少的给a，下一轮遍历按照新数组进行
	            b = t;
	            alen = biter;
	        }
			else 
			{
	            t = c;
	            c = a;
	            a = t;
	            alen = citer;
	        }
	
	    }
	    return re;
	}
	
	int main()
	{
		int a[7] = {1, 13,15, 2, 10,7, 8};
		int b[5];
		int c[5];
		int bit = 4;
		int alen = 7;
		cout << split(a, b, c, alen, bit);
		return 0;
	}

**B题**

问题：将一个n元一维向量（例数组）向左旋转i个位置。



- 求模置换法

	以i为除数对n求模，将向量遍历完并一次移动到位。移动x[0]到临时变量t，然后移动x[i]到x[0],x[2i]到x[i],依次类推，直到取到x[0]（其中下标都对长度n取模）；然后依次对x[1]...x[i-1]执行上面操作。

- 分段递归交换算法
	
	旋转向量x其实就是交换向量ab的两段，得到ba（a代表x中的前i个元素）。假设a比b短，将b分为b1和b2两段，使b2有跟a相同的长度，然后交换a和b2，也就是ab1b2交换得到b2b1a，a的位置已经是最终的位置，现在的问题集中到交换b2b1这两段，又回到了原来的问题。不断递归下去，到b1和b2的长度长度相等交换即可。

- 翻手法（也叫求逆法）

	把x向量分成ab两部分，a是前i个元素，b是后n-i个元素，首先对a求逆，然后对b求逆，然后对整体求逆得到ba。
	
	这里需要用到一个重要的性质：
	BA=(A<sup>r</sup>B<sup>r</sup>)<sup>r</sup>

	CBA=(A<sup>r</sup>B<sup>r</sup>C<sup>r</sup>)<sup>r</sup> 

	翻手算法代码非常简短，非常容易理解，而且针对字符串的求逆也不用自己写函数，在时间和空间上都很高效。（推荐此算法）

**C题**

问题：给定一个英语字典，找出其中的所有变位词集合。（变位词即由相同的字母，不同字母顺序组成的单词）

解题方法分为三步：

- （sign）标识单词

- （sort）把单词本身的字母排序

- （squash）找出排序后一样的字母

![](/images/c_bian2c.png)